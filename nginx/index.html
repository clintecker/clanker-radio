<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAST BYTE RADIO // CHICAGO WASTELAND</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --phosphor: #7fff7f;
            --phosphor-bright: #bfffbf;
            --phosphor-dim: #4a9a4a;
            --screen-bg: #050a05;
            --cyan: #00ffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: var(--screen-bg);
            color: var(--phosphor);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }

        /* CRT scan line effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        /* Header */
        header {
            margin-bottom: 40px;
            border-bottom: 1px solid var(--phosphor-dim);
            padding-bottom: 15px;
        }

        h1 {
            font-size: 1.2rem;
            letter-spacing: 0.3em;
            color: var(--phosphor-bright);
            margin-bottom: 5px;
        }

        .tagline {
            font-size: 0.7rem;
            color: var(--phosphor-dim);
            letter-spacing: 0.2em;
        }

        /* NOW PLAYING - THE STAR */
        .now-playing {
            margin-bottom: 50px;
            position: relative;
        }

        .np-label {
            font-size: 0.6rem;
            letter-spacing: 0.25em;
            color: var(--phosphor-dim);
            margin-bottom: 10px;
        }

        .np-title {
            font-size: 2rem;
            color: var(--phosphor-bright);
            margin-bottom: 8px;
            line-height: 1.2;
            text-shadow: 0 0 10px rgba(127, 255, 127, 0.5);
        }

        .np-artist {
            font-size: 1.2rem;
            color: var(--phosphor);
            margin-bottom: 15px;
        }

        .np-meta {
            font-size: 0.75rem;
            color: var(--phosphor-dim);
            margin-bottom: 15px;
        }

        /* Progress bar */
        .progress-container {
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 2px;
            background: rgba(127, 255, 127, 0.15);
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--phosphor);
            width: 0%;
            transition: width 0.5s linear;
            box-shadow: 0 0 8px var(--phosphor);
        }

        .progress-time {
            font-size: 0.65rem;
            color: var(--phosphor-dim);
            margin-top: 5px;
            font-variant-numeric: tabular-nums;
        }

        /* Stream section */
        .stream-section {
            margin-bottom: 50px;
        }

        .stream-header {
            font-size: 0.6rem;
            letter-spacing: 0.25em;
            color: var(--phosphor-dim);
            margin-bottom: 15px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(127, 255, 127, 0.1);
        }

        /* Player controls */
        .player-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .play-button {
            background: transparent;
            border: 1px solid var(--phosphor);
            color: var(--phosphor);
            padding: 12px 30px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .play-button:hover {
            background: rgba(127, 255, 127, 0.1);
            box-shadow: 0 0 15px rgba(127, 255, 127, 0.3);
        }

        .play-button.playing {
            background: rgba(127, 255, 127, 0.15);
            box-shadow: 0 0 10px rgba(127, 255, 127, 0.4);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-label {
            font-size: 0.6rem;
            color: var(--phosphor-dim);
            letter-spacing: 0.15em;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100px;
            height: 2px;
            background: rgba(127, 255, 127, 0.2);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--phosphor);
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--phosphor);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .quality-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .quality-label {
            font-size: 0.6rem;
            color: var(--phosphor-dim);
            letter-spacing: 0.15em;
        }

        .quality-selector {
            background: rgba(127, 255, 127, 0.1);
            border: 1px solid rgba(127, 255, 127, 0.3);
            color: var(--phosphor);
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.65rem;
            padding: 5px 8px;
            cursor: pointer;
            outline: none;
        }

        .quality-selector:hover {
            background: rgba(127, 255, 127, 0.15);
            border-color: var(--phosphor);
        }

        .quality-selector option {
            background: var(--screen-bg);
            color: var(--phosphor);
        }

        .stream-stats {
            display: flex;
            gap: 20px;
            font-size: 0.65rem;
            color: var(--phosphor-dim);
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat {
            display: flex;
            gap: 6px;
        }

        .stat-label {
            color: var(--phosphor-dim);
        }

        .stat-value {
            color: var(--phosphor);
            font-variant-numeric: tabular-nums;
        }

        /* Stream links */
        .stream-links {
            display: flex;
            gap: 15px;
        }

        .stream-link {
            flex: 1;
            padding: 12px;
            text-align: center;
            text-decoration: none;
            color: var(--phosphor);
            border: 1px solid var(--phosphor-dim);
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            transition: all 0.2s;
            background: rgba(127, 255, 127, 0.03);
        }

        .stream-link:hover {
            border-color: var(--phosphor);
            background: rgba(127, 255, 127, 0.08);
            box-shadow: 0 0 15px rgba(127, 255, 127, 0.2);
        }

        /* Next up & History */
        .section {
            margin-bottom: 40px;
        }

        .section-header {
            font-size: 0.6rem;
            letter-spacing: 0.25em;
            color: var(--phosphor-dim);
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(127, 255, 127, 0.1);
        }

        .track {
            padding: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 15px;
            border-bottom: 1px solid rgba(127, 255, 127, 0.05);
            font-size: 0.8rem;
        }

        .track:last-child {
            border-bottom: none;
        }

        .track-info {
            flex: 1;
            min-width: 0;
        }

        .track-title {
            color: var(--phosphor);
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-artist {
            color: var(--phosphor-dim);
            font-size: 0.7rem;
        }

        .track-time {
            color: var(--phosphor-dim);
            font-size: 0.65rem;
            white-space: nowrap;
            font-variant-numeric: tabular-nums;
        }

        /* Next track styling */
        .next-track .track-title {
            color: var(--cyan);
        }

        /* Status indicator */
        .status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.65rem;
            color: var(--phosphor-dim);
            margin-left: 10px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            background: var(--phosphor);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Responsive */
        @media (max-width: 600px) {
            .np-title {
                font-size: 1.5rem;
            }
            .np-artist {
                font-size: 1rem;
            }
            .stream-links {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <h1>LAST BYTE RADIO</h1>
            <div class="tagline">CHICAGO WASTELAND // ENCRYPTED BROADCAST</div>
        </header>

        <!-- NOW PLAYING -->
        <section class="now-playing">
            <div class="np-label">
                NOW TRANSMITTING
                <span class="status">
                    <span class="status-dot"></span>
                    LIVE
                </span>
            </div>
            <div class="np-title" id="current-title">Loading...</div>
            <div class="np-artist" id="current-artist"></div>
            <div class="np-meta" id="current-meta"></div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-time">
                    <span id="current-time">0:00</span> / <span id="total-time">0:00</span>
                </div>
            </div>
        </section>

        <!-- Stream Info -->
        <section class="stream-section">
            <div class="stream-header">STREAM CONTROLS</div>

            <!-- Hidden audio element -->
            <audio id="radio-stream" preload="none">
                <source src="/radio-128" type="audio/mpeg">
            </audio>

            <!-- Custom player controls -->
            <div class="player-controls">
                <button id="play-button" class="play-button">TUNE IN</button>
                <div class="volume-control">
                    <span class="volume-label">VOL</span>
                    <input type="range" id="volume" min="0" max="100" value="70">
                </div>
                <div class="quality-control">
                    <span class="quality-label">QUALITY</span>
                    <select id="quality-selector" class="quality-selector">
                        <option value="/radio-96">96 kbps (Low)</option>
                        <option value="/radio-128" selected>128 kbps (Default)</option>
                        <option value="/radio">192 kbps (High)</option>
                    </select>
                </div>
            </div>

            <div class="stream-stats">
                <div class="stat">
                    <span class="stat-label">LISTENERS:</span>
                    <span class="stat-value" id="listeners">—</span>
                </div>
                <div class="stat">
                    <span class="stat-label">BITRATE:</span>
                    <span class="stat-value" id="bitrate">—</span>
                </div>
                <div class="stat">
                    <span class="stat-label">SAMPLE RATE:</span>
                    <span class="stat-value" id="samplerate">—</span>
                </div>
                <div class="stat">
                    <span class="stat-label">UPTIME:</span>
                    <span class="stat-value" id="uptime">—</span>
                </div>
            </div>

        </section>

        <!-- Next Up -->
        <section class="section">
            <div class="section-header">NEXT UP</div>
            <div class="next-track" id="next-track">
                <div class="track">
                    <div class="track-info">
                        <div class="track-title">—</div>
                        <div class="track-artist">—</div>
                    </div>
                    <div class="track-time">—</div>
                </div>
            </div>
        </section>

        <!-- Recent Transmission Log -->
        <section class="section">
            <div class="section-header">RECENT TRANSMISSIONS</div>
            <div id="history-list"></div>
        </section>

        <!-- Footer -->
        <footer style="margin-top: 50px; padding-top: 20px; border-top: 1px solid rgba(127, 255, 127, 0.1); text-align: center;">
            <a href="/stream.m3u" download style="color: var(--phosphor-dim); text-decoration: none; font-size: 0.65rem; letter-spacing: 0.15em;">DOWNLOAD M3U PLAYLIST</a>
        </footer>
    </div>

    <script>
        const API_URL = '/api/now_playing.json';
        const UPDATE_INTERVAL = 2000;  // 2 seconds for more responsive updates

        let currentTrack = null;
        let trackStartTime = null;

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function calculateProgress() {
            if (!currentTrack || !trackStartTime) {
                console.debug('calculateProgress: no track or start time');
                return;
            }

            const now = new Date();
            const elapsed = (now - trackStartTime) / 1000; // seconds
            const duration = currentTrack.duration_sec || 0;

            // Clamp elapsed time to duration for both display and progress bar
            const displayElapsed = duration > 0 ? Math.min(elapsed, duration) : elapsed;
            document.getElementById('current-time').textContent = formatTime(displayElapsed);

            // Update progress bar if we have a valid duration
            if (duration > 0) {
                const percent = (displayElapsed / duration) * 100;
                document.getElementById('progress-fill').style.width = `${percent}%`;
            } else {
                // No duration available - show indeterminate state
                document.getElementById('progress-fill').style.width = '0%';
            }
        }

        function formatUptime(streamStart) {
            if (!streamStart) return '—';
            const start = new Date(streamStart);
            const now = new Date();
            const diffMs = now - start;
            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            return `${hours}h ${minutes}m`;
        }

        function updateDisplay(data) {
            const current = data.current;
            const next = data.next;
            const history = data.history || [];
            const stream = data.stream || {};

            // Extract main stream info from source array (if present)
            const mainStream = (stream.source && stream.source[0]) || stream;

            if (!current) {
                document.getElementById('current-title').textContent = 'NO SIGNAL';
                document.getElementById('current-artist').textContent = '';
                document.getElementById('current-meta').textContent = '';
                document.querySelector('.progress-container').style.display = 'none';
                return;
            }

            // Show progress bar if we have a track
            document.querySelector('.progress-container').style.display = 'block';

            // Update stream stats (read from mainStream which is either source[0] or legacy format)
            document.getElementById('listeners').textContent = mainStream.listeners || '—';
            document.getElementById('bitrate').textContent = mainStream.bitrate ? `${mainStream.bitrate}kbps` : '—';
            document.getElementById('samplerate').textContent = mainStream.samplerate ? `${mainStream.samplerate}Hz` : '—';
            document.getElementById('uptime').textContent = formatUptime(mainStream.stream_start_iso8601 || mainStream.stream_start);

            // Update now playing
            document.getElementById('current-title').textContent = current.title || 'Unknown Track';
            document.getElementById('current-artist').textContent = current.artist || 'Unknown Artist';

            // Build meta line
            let meta = [];
            if (current.album && current.album !== 'Unknown Album') {
                meta.push(current.album);
            }
            if (current.source) {
                meta.push(`[${current.source.toUpperCase()}]`);
            }
            document.getElementById('current-meta').textContent = meta.join(' · ');

            // Update duration
            document.getElementById('total-time').textContent = formatTime(current.duration_sec);

            // Calculate start time from played_at timestamp
            if (current.played_at) {
                const newStartTime = new Date(current.played_at);
                const isNewTrack = !currentTrack || currentTrack.asset_id !== current.asset_id;
                const playedAtChanged = currentTrack && currentTrack.played_at !== current.played_at;

                // Update if this is a different track OR if played_at changed (new play of same track)
                if (isNewTrack || playedAtChanged) {
                    console.log('Track update:', {
                        isNewTrack,
                        playedAtChanged,
                        asset_id: current.asset_id,
                        played_at: current.played_at,
                        duration: current.duration_sec
                    });
                    trackStartTime = newStartTime;
                    currentTrack = current;
                }
            }

            // Update next track
            const nextContainer = document.getElementById('next-track');
            if (next) {
                nextContainer.innerHTML = `
                    <div class="track">
                        <div class="track-info">
                            <div class="track-title">${next.title || 'Unknown'}</div>
                            <div class="track-artist">${next.artist || 'Unknown Artist'}</div>
                        </div>
                        <div class="track-time">${formatTime(next.duration_sec)}</div>
                    </div>
                `;
            } else {
                nextContainer.innerHTML = `
                    <div class="track">
                        <div class="track-info">
                            <div class="track-title">—</div>
                        </div>
                    </div>
                `;
            }

            // Update history
            const historyList = document.getElementById('history-list');
            if (history.length > 0) {
                historyList.innerHTML = history.slice(0, 6).map(track => {
                    const playedAt = track.played_at ? new Date(track.played_at) : null;
                    const timeAgo = playedAt ? formatTimeAgo(playedAt) : '';

                    return `
                        <div class="track">
                            <div class="track-info">
                                <div class="track-title">${track.title || 'Unknown'}</div>
                                <div class="track-artist">${track.artist || 'Unknown Artist'}</div>
                            </div>
                            <div class="track-time">${timeAgo}</div>
                        </div>
                    `;
                }).join('');
            } else {
                historyList.innerHTML = '<div class="track"><div class="track-info"><div class="track-title">No history available</div></div></div>';
            }
        }

        function formatTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            return `${hours}h ago`;
        }

        async function fetchData() {
            try {
                const response = await fetch(API_URL + '?' + new Date().getTime());
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                const data = await response.json();
                console.debug('Fetched data:', data.current ? {
                    asset_id: data.current.asset_id,
                    title: data.current.title,
                    played_at: data.current.played_at,
                    duration_sec: data.current.duration_sec
                } : 'no current track');
                updateDisplay(data);
            } catch (error) {
                console.error('Failed to fetch now playing data:', error);
                // Show error state in UI
                document.getElementById('current-title').textContent = 'ERROR LOADING DATA';
                document.getElementById('current-artist').textContent = error.message;
            }
        }

        // Player controls
        const audio = document.getElementById('radio-stream');
        const playButton = document.getElementById('play-button');
        const volumeSlider = document.getElementById('volume');
        const qualitySelector = document.getElementById('quality-selector');

        // Start muted and auto-play (stream is always broadcasting)
        audio.muted = true;
        audio.volume = 0.7;

        // Auto-start the stream (muted)
        audio.play().catch(err => {
            console.log('Auto-play blocked, waiting for user interaction');
        });

        playButton.addEventListener('click', () => {
            if (audio.muted) {
                // Unmute (tune in)
                audio.muted = false;
                audio.play(); // Ensure it's playing
                playButton.textContent = 'MUTE';
                playButton.classList.add('playing');
            } else {
                // Mute (tune out)
                audio.muted = true;
                playButton.textContent = 'TUNE IN';
                playButton.classList.remove('playing');
            }
        });

        volumeSlider.addEventListener('input', (e) => {
            audio.volume = e.target.value / 100;
            // If user adjusts volume, unmute automatically
            if (audio.muted && e.target.value > 0) {
                audio.muted = false;
                playButton.textContent = 'MUTE';
                playButton.classList.add('playing');
            }
        });

        // Handle quality changes
        qualitySelector.addEventListener('change', function() {
            const wasPlaying = !audio.paused;
            const wasMuted = audio.muted;

            // Update audio source
            audio.src = this.value;

            // Resume playback if it was playing
            if (wasPlaying) {
                audio.load();
                audio.play().catch(err => {
                    console.error('Failed to switch quality:', err);
                });

                // Restore mute state
                audio.muted = wasMuted;
            }
        });

        // Update progress bar continuously
        setInterval(calculateProgress, 500);

        // Fetch data periodically
        fetchData();
        setInterval(fetchData, UPDATE_INTERVAL);
    </script>
</body>
</html>
