<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAST BYTE RADIO // CHICAGO WASTELAND</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        :root {
            --phosphor: #7fff7f;
            --phosphor-bright: #bfffbf;
            --phosphor-dim: #4a9a4a;
            --screen-bg: #050a05;
            --cyan: #00ffff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background: var(--screen-bg);
            color: var(--phosphor);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }

        /* CRT scan line effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        /* Header */
        header {
            margin-bottom: 40px;
            border-bottom: 1px solid var(--phosphor-dim);
            padding-bottom: 15px;
        }

        h1 {
            font-size: 1.2rem;
            letter-spacing: 0.3em;
            color: var(--phosphor-bright);
            margin-bottom: 5px;
        }

        .tagline {
            font-size: 0.7rem;
            color: var(--phosphor-dim);
            letter-spacing: 0.2em;
        }

        /* NOW PLAYING - THE STAR */
        .now-playing {
            margin-bottom: 50px;
            position: relative;
        }

        .np-label {
            font-size: 0.6rem;
            letter-spacing: 0.25em;
            color: var(--phosphor-dim);
            margin-bottom: 10px;
        }

        .status {
            margin-left: 15px;
            font-size: 0.65rem;
        }

        .status-dot {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            margin-right: 6px;
            animation: pulse 2s infinite;
        }

        .status-online .status-dot {
            background: var(--phosphor);
            box-shadow: 0 0 6px var(--phosphor);
        }

        .status-restarting .status-dot {
            background: var(--yellow);
            box-shadow: 0 0 6px var(--yellow);
            animation: pulse 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Crossfade incoming track display */
        .crossfade-incoming {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(127, 255, 127, 0.2);
            animation: fadeIn 1s ease-in;
        }

        .crossfade-label {
            font-size: 0.6rem;
            letter-spacing: 0.25em;
            color: var(--yellow);
            margin-bottom: 8px;
        }

        .crossfade-title {
            font-size: 1.5rem;
            color: var(--phosphor);
            margin-bottom: 6px;
            opacity: 0;
            animation: fadeIn 2s ease-in forwards;
        }

        .crossfade-artist {
            font-size: 0.9rem;
            color: var(--phosphor-dim);
            opacity: 0;
            animation: fadeIn 2s ease-in 0.5s forwards;
        }

        .crossfading .np-title,
        .crossfading .np-artist,
        .crossfading .np-meta {
            animation: glitchOut 3s ease-in forwards;
        }

        /* Fade in from blurred background for incoming track */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.98);
                filter: blur(4px) brightness(0.7);
            }
            to {
                opacity: 1;
                transform: scale(1);
                filter: none;
            }
        }

        /* Glitch out with static/unplugging effect for departing track */
        @keyframes glitchOut {
            0% {
                opacity: 1;
                transform: translateX(0);
                filter: none;
            }
            15% {
                opacity: 0.9;
                transform: translateX(-1px);
            }
            30% {
                opacity: 0.75;
                transform: translateX(2px);
                filter: hue-rotate(20deg) saturate(0.8);
            }
            35% {
                opacity: 0.8;
                transform: translateX(-2px);
            }
            50% {
                opacity: 0.6;
                transform: translateX(1px);
                filter: blur(0.5px) brightness(1.3);
            }
            65% {
                opacity: 0.4;
                transform: translateX(-1px);
                filter: blur(1px) saturate(0.3);
            }
            75% {
                opacity: 0.3;
                transform: translateX(2px);
                filter: brightness(1.5) saturate(0);
            }
            85% {
                opacity: 0.15;
                transform: translateX(-1px);
                filter: blur(2px) brightness(2);
            }
            92% {
                opacity: 0.1;
                transform: translateX(1px);
            }
            100% {
                opacity: 0;
                transform: translateX(0);
                filter: blur(3px) brightness(3) saturate(0);
            }
        }

        .np-title {
            font-size: 2rem;
            color: var(--phosphor-bright);
            margin-bottom: 8px;
            line-height: 1.2;
            text-shadow: 0 0 10px rgba(127, 255, 127, 0.5);
        }

        .np-artist {
            font-size: 1.2rem;
            color: var(--phosphor);
            margin-bottom: 15px;
        }

        .np-meta {
            font-size: 0.75rem;
            color: var(--phosphor-dim);
            margin-bottom: 15px;
        }

        /* Progress bar */
        .progress-container {
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .progress-bar {
            width: 100%;
            height: 2px;
            background: rgba(127, 255, 127, 0.15);
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--phosphor);
            width: 0%;
            transition: width 0.5s linear;
            box-shadow: 0 0 8px var(--phosphor);
        }

        .progress-time {
            font-size: 0.65rem;
            color: var(--phosphor-dim);
            margin-top: 5px;
            font-variant-numeric: tabular-nums;
        }

        /* Stream section */
        .stream-section {
            margin-bottom: 50px;
        }

        .stream-header {
            font-size: 0.6rem;
            letter-spacing: 0.25em;
            color: var(--phosphor-dim);
            margin-bottom: 15px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(127, 255, 127, 0.1);
        }

        /* Player controls */
        .player-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .play-button {
            background: transparent;
            border: 1px solid var(--phosphor);
            color: var(--phosphor);
            padding: 12px 30px;
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .play-button:hover {
            background: rgba(127, 255, 127, 0.1);
            box-shadow: 0 0 15px rgba(127, 255, 127, 0.3);
        }

        .play-button.playing {
            background: rgba(127, 255, 127, 0.15);
            box-shadow: 0 0 10px rgba(127, 255, 127, 0.4);
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .volume-label {
            font-size: 0.6rem;
            color: var(--phosphor-dim);
            letter-spacing: 0.15em;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100px;
            height: 2px;
            background: rgba(127, 255, 127, 0.2);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--phosphor);
            cursor: pointer;
            border-radius: 50%;
        }

        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--phosphor);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .quality-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .quality-label {
            font-size: 0.6rem;
            color: var(--phosphor-dim);
            letter-spacing: 0.15em;
        }

        .quality-selector {
            background: rgba(127, 255, 127, 0.1);
            border: 1px solid rgba(127, 255, 127, 0.3);
            color: var(--phosphor);
            font-family: 'Share Tech Mono', monospace;
            font-size: 0.65rem;
            padding: 5px 8px;
            cursor: pointer;
            outline: none;
        }

        .quality-selector:hover {
            background: rgba(127, 255, 127, 0.15);
            border-color: var(--phosphor);
        }

        .quality-selector option {
            background: var(--screen-bg);
            color: var(--phosphor);
        }

        .stream-stats {
            display: flex;
            gap: 20px;
            font-size: 0.65rem;
            color: var(--phosphor-dim);
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .stat {
            display: flex;
            gap: 6px;
        }

        .stat-label {
            color: var(--phosphor-dim);
        }

        .stat-value {
            color: var(--phosphor);
            font-variant-numeric: tabular-nums;
        }

        /* Stream links */
        .stream-links {
            display: flex;
            gap: 15px;
        }

        .stream-link {
            flex: 1;
            padding: 12px;
            text-align: center;
            text-decoration: none;
            color: var(--phosphor);
            border: 1px solid var(--phosphor-dim);
            font-size: 0.7rem;
            letter-spacing: 0.15em;
            transition: all 0.2s;
            background: rgba(127, 255, 127, 0.03);
        }

        .stream-link:hover {
            border-color: var(--phosphor);
            background: rgba(127, 255, 127, 0.08);
            box-shadow: 0 0 15px rgba(127, 255, 127, 0.2);
        }

        /* Next up & History */
        .section {
            margin-bottom: 40px;
        }

        .section-header {
            font-size: 0.6rem;
            letter-spacing: 0.25em;
            color: var(--phosphor-dim);
            margin-bottom: 12px;
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(127, 255, 127, 0.1);
        }

        .track {
            padding: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 15px;
            border-bottom: 1px solid rgba(127, 255, 127, 0.05);
            font-size: 0.8rem;
        }

        .track:last-child {
            border-bottom: none;
        }

        /* Station ID (bumper) styling */
        .track-bumper {
            opacity: 0.6;
        }

        .track-bumper .track-title {
            color: var(--cyan);
            font-style: italic;
        }

        .track-bumper .track-artist {
            color: var(--phosphor-dim);
        }

        /* News break styling */
        .track-break {
            opacity: 0.6;
        }

        .track-break .track-title {
            color: var(--yellow);
            font-style: italic;
        }

        .track-break .track-artist {
            color: var(--phosphor-dim);
        }

        .track-info {
            flex: 1;
            min-width: 0;
        }

        .track-title {
            color: var(--phosphor);
            margin-bottom: 3px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .track-artist {
            color: var(--phosphor-dim);
            font-size: 0.7rem;
        }

        .track-time {
            color: var(--phosphor-dim);
            font-size: 0.65rem;
            white-space: nowrap;
            font-variant-numeric: tabular-nums;
        }

        /* Next track styling */
        .next-track .track-title {
            color: var(--cyan);
        }

        /* Status indicator */
        .status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.65rem;
            color: var(--phosphor-dim);
            margin-left: 10px;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            background: var(--phosphor);
            border-radius: 50%;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Responsive */
        @media (max-width: 600px) {
            .np-title {
                font-size: 1.5rem;
            }
            .np-artist {
                font-size: 1rem;
            }
            .stream-links {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <h1>LAST BYTE RADIO</h1>
            <div class="tagline">CHICAGO WASTELAND // ENCRYPTED BROADCAST</div>
        </header>

        <!-- NOW PLAYING -->
        <section class="now-playing">
            <div class="np-label">
                NOW TRANSMITTING
                <span class="status status-online" id="system-status">
                    <span class="status-dot"></span>
                    <span id="status-text">LIVE</span>
                </span>
            </div>
            <div class="np-title" id="current-title">Loading...</div>
            <div class="np-artist" id="current-artist"></div>
            <div class="np-meta" id="current-meta"></div>

            <!-- Incoming track during crossfade -->
            <div class="crossfade-incoming" id="crossfade-incoming" style="display: none;">
                <div class="crossfade-label">â†“ FADING IN</div>
                <div class="crossfade-title" id="incoming-title"></div>
                <div class="crossfade-artist" id="incoming-artist"></div>
            </div>

            <div class="progress-container">
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <div class="progress-time">
                    <span id="current-time">0:00</span> / <span id="total-time">0:00</span>
                </div>
            </div>
        </section>

        <!-- Stream Info -->
        <section class="stream-section">
            <div class="stream-header">STREAM CONTROLS</div>

            <!-- Hidden audio element -->
            <audio id="radio-stream" preload="none">
                <source src="/radio-128" type="audio/mpeg">
            </audio>

            <!-- Custom player controls -->
            <div class="player-controls">
                <button id="play-button" class="play-button">TUNE IN</button>
                <div class="volume-control">
                    <span class="volume-label">VOL</span>
                    <input type="range" id="volume" min="0" max="100" value="70">
                </div>
                <div class="quality-control">
                    <span class="quality-label">QUALITY</span>
                    <select id="quality-selector" class="quality-selector">
                        <option value="/radio-96">96 kbps (Low)</option>
                        <option value="/radio-128" selected>128 kbps (Default)</option>
                        <option value="/radio">192 kbps (High)</option>
                    </select>
                </div>
            </div>

            <div class="stream-stats">
                <div class="stat">
                    <span class="stat-label">LISTENERS:</span>
                    <span class="stat-value" id="listeners">â€”</span>
                </div>
                <div class="stat">
                    <span class="stat-label">BITRATE:</span>
                    <span class="stat-value" id="bitrate">â€”</span>
                </div>
                <div class="stat">
                    <span class="stat-label">SAMPLE RATE:</span>
                    <span class="stat-value" id="samplerate">â€”</span>
                </div>
                <div class="stat">
                    <span class="stat-label">UPTIME:</span>
                    <span class="stat-value" id="uptime">â€”</span>
                </div>
            </div>

        </section>

        <!-- Next Up -->
        <section class="section">
            <div class="section-header">NEXT UP</div>
            <div class="next-track" id="next-track">
                <div class="track">
                    <div class="track-info">
                        <div class="track-title">â€”</div>
                        <div class="track-artist">â€”</div>
                    </div>
                    <div class="track-time">â€”</div>
                </div>
            </div>
        </section>

        <!-- Recent Transmission Log -->
        <section class="section">
            <div class="section-header">RECENT TRANSMISSIONS</div>
            <div id="history-list"></div>
        </section>

        <!-- Footer -->
        <footer style="margin-top: 50px; padding-top: 20px; border-top: 1px solid rgba(127, 255, 127, 0.1); text-align: center;">
            <a href="/stream.m3u" download style="color: var(--phosphor-dim); text-decoration: none; font-size: 0.65rem; letter-spacing: 0.15em;">DOWNLOAD M3U PLAYLIST</a>
        </footer>
    </div>

    <script>
        const SSE_URL = '/api/stream';  // Server-Sent Events endpoint

        let currentTrack = null;
        let trackStartTime = null;
        let eventSource = null;
        let currentBitrate = 128;  // Track selected bitrate for stats display
        let lastData = null;  // Store last SSE data for quality switching
        let crossfadeSettings = { music_sec: 4.0, breaks_sec: 0.0 };  // Crossfade durations
        let inCrossfade = false;  // Track if we're currently in crossfade

        function formatTime(seconds) {
            if (!seconds || isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function calculateProgress() {
            if (!currentTrack || !trackStartTime) {
                console.debug('calculateProgress: no track or start time');
                return;
            }

            const now = new Date();
            const elapsed = (now - trackStartTime) / 1000; // seconds
            const duration = currentTrack.duration_sec || 0;

            // Clamp elapsed time to duration for both display and progress bar
            const displayElapsed = duration > 0 ? Math.min(elapsed, duration) : elapsed;
            document.getElementById('current-time').textContent = formatTime(displayElapsed);

            // Update progress bar if we have a valid duration
            if (duration > 0) {
                const percent = (displayElapsed / duration) * 100;
                document.getElementById('progress-fill').style.width = `${percent}%`;
            } else {
                // No duration available - show indeterminate state
                document.getElementById('progress-fill').style.width = '0%';
            }

            // Check if we're in crossfade window
            if (lastData && duration > 0) {
                const breaksQueue = lastData.breaks_queue || [];
                const musicQueue = lastData.music_queue || [];

                // Determine next track and crossfade duration
                let nextTrack = null;
                let crossfadeDuration = 0;

                if (breaksQueue.length > 0) {
                    nextTrack = breaksQueue[0];
                    crossfadeDuration = crossfadeSettings.breaks_sec;
                } else if (musicQueue.length > 0) {
                    nextTrack = musicQueue[0];
                    crossfadeDuration = crossfadeSettings.music_sec;
                }

                if (nextTrack && crossfadeDuration > 0) {
                    const timeRemaining = duration - elapsed;
                    const inCrossfadeWindow = timeRemaining <= crossfadeDuration && timeRemaining > 0;

                    if (inCrossfadeWindow && !inCrossfade) {
                        // Start crossfade
                        console.log('ðŸŽµ CROSSFADE START:', {
                            timeRemaining,
                            crossfadeDuration,
                            nextTrack: nextTrack.title
                        });
                        inCrossfade = true;
                        document.querySelector('.now-playing').classList.add('crossfading');
                        document.getElementById('crossfade-incoming').style.display = 'block';
                        document.getElementById('incoming-title').textContent = nextTrack.title || 'Unknown';
                        document.getElementById('incoming-artist').textContent = nextTrack.artist || 'Unknown Artist';
                    } else if (!inCrossfadeWindow && inCrossfade) {
                        // End crossfade
                        console.log('ðŸŽµ CROSSFADE END');
                        inCrossfade = false;
                        document.querySelector('.now-playing').classList.remove('crossfading');
                        document.getElementById('crossfade-incoming').style.display = 'none';
                    }
                } else if (inCrossfade) {
                    // No crossfade for this track (breaks), hide incoming
                    inCrossfade = false;
                    document.querySelector('.now-playing').classList.remove('crossfading');
                    document.getElementById('crossfade-incoming').style.display = 'none';
                }
            }
        }

        function formatUptime(streamStart) {
            if (!streamStart) return 'â€”';
            const start = new Date(streamStart);
            const now = new Date();
            const diffMs = now - start;
            const hours = Math.floor(diffMs / (1000 * 60 * 60));
            const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
            return `${hours}h ${minutes}m`;
        }

        function updateDisplay(data) {
            // Store data for quality switching
            lastData = data;

            // Update system status indicator
            const statusEl = document.getElementById('system-status');
            const statusText = document.getElementById('status-text');
            if (data.system_status) {
                if (data.system_status === 'restarting') {
                    statusEl.className = 'status status-restarting';
                    statusText.textContent = 'RESTARTING';
                } else {
                    statusEl.className = 'status status-online';
                    statusText.textContent = 'LIVE';
                }
            }

            // Store crossfade settings
            if (data.crossfade) {
                crossfadeSettings = data.crossfade;
            }

            const current = data.current;
            const breaksQueue = data.breaks_queue || [];
            const musicQueue = data.music_queue || [];
            const history = data.history || [];
            const stream = data.stream || {};

            // Find the stream matching the selected bitrate
            let selectedStream = null;
            if (stream.source && stream.source.length > 0) {
                // Find stream by bitrate
                selectedStream = stream.source.find(s => s.bitrate === currentBitrate);
                // Fallback to first stream if not found
                if (!selectedStream) selectedStream = stream.source[0];
            } else {
                // Legacy format
                selectedStream = stream;
            }
            const mainStream = selectedStream || {};

            if (!current) {
                document.getElementById('current-title').textContent = 'NO SIGNAL';
                document.getElementById('current-artist').textContent = '';
                document.getElementById('current-meta').textContent = '';
                document.querySelector('.progress-container').style.display = 'none';
                return;
            }

            // Show progress bar if we have a track
            document.querySelector('.progress-container').style.display = 'block';

            // Update stream stats (read from mainStream which is either source[0] or legacy format)
            document.getElementById('listeners').textContent = mainStream.listeners || 'â€”';
            document.getElementById('bitrate').textContent = mainStream.bitrate ? `${mainStream.bitrate}kbps` : 'â€”';
            document.getElementById('samplerate').textContent = mainStream.samplerate ? `${mainStream.samplerate}Hz` : 'â€”';
            document.getElementById('uptime').textContent = formatUptime(mainStream.stream_start_iso8601 || mainStream.stream_start);

            // Update now playing
            document.getElementById('current-title').textContent = current.title || 'Unknown Track';
            document.getElementById('current-artist').textContent = current.artist || 'Unknown Artist';

            // Build meta line
            let meta = [];
            if (current.album && current.album !== 'Unknown Album') {
                meta.push(current.album);
            }
            if (current.source) {
                meta.push(`[${current.source.toUpperCase()}]`);
            }
            document.getElementById('current-meta').textContent = meta.join(' Â· ');

            // Update duration
            document.getElementById('total-time').textContent = formatTime(current.duration_sec);

            // Calculate start time from played_at timestamp
            if (current.played_at) {
                const newStartTime = new Date(current.played_at);
                const isNewTrack = !currentTrack || currentTrack.asset_id !== current.asset_id;
                const playedAtChanged = currentTrack && currentTrack.played_at !== current.played_at;

                // Update if this is a different track OR if played_at changed (new play of same track)
                if (isNewTrack || playedAtChanged) {
                    console.log('Track update:', {
                        isNewTrack,
                        playedAtChanged,
                        asset_id: current.asset_id,
                        played_at: current.played_at,
                        duration: current.duration_sec
                    });
                    trackStartTime = newStartTime;
                    currentTrack = current;
                }
            }

            // Update next track display based on queue structure
            // Breaks queue has priority - if it has items, they play first
            const nextContainer = document.getElementById('next-track');

            if (breaksQueue.length > 0) {
                // Break/station ID will play next
                const nextBreak = breaksQueue[0];
                const nextMusic = musicQueue[0];
                const breakClass = nextBreak.source === 'bumper' ? 'track track-bumper' :
                                  nextBreak.source === 'break' ? 'track track-break' : 'track';

                nextContainer.innerHTML = `
                    <div class="${breakClass}">
                        <div class="track-info">
                            <div class="track-title">${nextBreak.title || 'Unknown'}</div>
                            <div class="track-artist">${nextBreak.artist || 'Unknown Artist'}</div>
                        </div>
                        <div class="track-time">${formatTime(nextBreak.duration_sec)}</div>
                    </div>
                    ${nextMusic ? `
                    <div class="track" style="opacity: 0.5; font-size: 0.9em; margin-top: 0.5rem;">
                        <div class="track-info">
                            <div class="track-title">â†³ Then: ${nextMusic.title || 'Unknown'}</div>
                            <div class="track-artist">${nextMusic.artist || 'Unknown Artist'}</div>
                        </div>
                        <div class="track-time">${formatTime(nextMusic.duration_sec)}</div>
                    </div>
                    ` : ''}
                `;
            } else if (musicQueue.length > 0) {
                // Music plays next (no breaks queued)
                const nextMusic = musicQueue[0];
                nextContainer.innerHTML = `
                    <div class="track">
                        <div class="track-info">
                            <div class="track-title">${nextMusic.title || 'Unknown'}</div>
                            <div class="track-artist">${nextMusic.artist || 'Unknown Artist'}</div>
                        </div>
                        <div class="track-time">${formatTime(nextMusic.duration_sec)}</div>
                    </div>
                `;
            } else {
                // No tracks in queue
                nextContainer.innerHTML = `
                    <div class="track">
                        <div class="track-info">
                            <div class="track-title">â€”</div>
                        </div>
                    </div>
                `;
            }

            // Update history
            const historyList = document.getElementById('history-list');
            if (history.length > 0) {
                historyList.innerHTML = history.map(track => {
                    const playedAt = track.played_at ? new Date(track.played_at) : null;
                    const timeAgo = playedAt ? formatTimeAgo(playedAt) : '';
                    // Add class for bumpers (station IDs) and breaks (news)
                    const trackClass = track.source === 'bumper' ? 'track track-bumper' :
                                      track.source === 'break' ? 'track track-break' : 'track';

                    return `
                        <div class="${trackClass}">
                            <div class="track-info">
                                <div class="track-title">${track.title || 'Unknown'}</div>
                                <div class="track-artist">${track.artist || 'Unknown Artist'}</div>
                            </div>
                            <div class="track-time">${timeAgo}</div>
                        </div>
                    `;
                }).join('');
            } else {
                historyList.innerHTML = '<div class="track"><div class="track-info"><div class="track-title">No history available</div></div></div>';
            }
        }

        function formatTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            return `${hours}h ago`;
        }

        function connectSSE() {
            console.log('Connecting to SSE endpoint...');

            eventSource = new EventSource(SSE_URL);

            eventSource.onopen = () => {
                console.log('SSE connection established');
            };

            eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('SSE Update received:', {
                        updated_at: data.updated_at,
                        current: data.current,
                        breaks_queue: data.breaks_queue,
                        music_queue: data.music_queue,
                        history: data.history,
                        stream: data.stream,
                        full_payload: data
                    });
                    updateDisplay(data);
                } catch (error) {
                    console.error('Failed to parse SSE data:', error);
                }
            };

            eventSource.onerror = (error) => {
                console.error('SSE connection error:', error);
                eventSource.close();

                // Reconnect after 5 seconds
                setTimeout(() => {
                    console.log('Reconnecting to SSE...');
                    connectSSE();
                }, 5000);
            };
        }

        // Player controls
        const audio = document.getElementById('radio-stream');
        const playButton = document.getElementById('play-button');
        const volumeSlider = document.getElementById('volume');
        const qualitySelector = document.getElementById('quality-selector');

        // Start muted and auto-play (stream is always broadcasting)
        audio.muted = true;
        audio.volume = 0.7;

        // Auto-start the stream (muted)
        audio.play().catch(err => {
            console.log('Auto-play blocked, waiting for user interaction');
        });

        playButton.addEventListener('click', () => {
            if (audio.muted) {
                // Unmute (tune in)
                audio.muted = false;
                audio.play(); // Ensure it's playing
                playButton.textContent = 'MUTE';
                playButton.classList.add('playing');
            } else {
                // Mute (tune out)
                audio.muted = true;
                playButton.textContent = 'TUNE IN';
                playButton.classList.remove('playing');
            }
        });

        volumeSlider.addEventListener('input', (e) => {
            audio.volume = e.target.value / 100;
            // If user adjusts volume, unmute automatically
            if (audio.muted && e.target.value > 0) {
                audio.muted = false;
                playButton.textContent = 'MUTE';
                playButton.classList.add('playing');
            }
        });

        // Handle quality changes
        qualitySelector.addEventListener('change', function() {
            const wasPlaying = !audio.paused;
            const wasMuted = audio.muted;

            // Update current bitrate for stats display
            const bitrateMap = {
                '/radio-96': 96,
                '/radio-128': 128,
                '/radio': 192
            };
            currentBitrate = bitrateMap[this.value] || 128;
            console.log('Selected bitrate:', currentBitrate);

            // Update all stream stats for selected quality
            if (lastData) {
                updateDisplay(lastData);
            }

            // Update audio source
            audio.src = this.value;

            // Resume playback if it was playing
            if (wasPlaying) {
                audio.load();
                audio.play().catch(err => {
                    console.error('Failed to switch quality:', err);
                });

                // Restore mute state
                audio.muted = wasMuted;
            }
        });

        // Update progress bar continuously
        setInterval(calculateProgress, 500);

        // Connect to SSE stream
        console.log('Connecting to SSE for real-time updates');
        connectSSE();
    </script>
</body>
</html>
